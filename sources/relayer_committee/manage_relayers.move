module mobility_protocol::manage_relayers;

use mobility_protocol::errors;
use mobility_protocol::owner;
use sui::event;
use sui::table;

// ===== One time witness structs =====

/// Serves as the one time witness to create the relayer registry
/// during module initialization.
public struct MANAGE_RELAYERS has drop {}

// ===== Global storage structs =====

/// The relayer registry to track whitelisted relayers.
/// Stores the relayer table with the structure relayer (address) ->
/// is_whitelisted (bool) and the number of active relayers.
public struct RelayerRegistry has key {
    id: object::UID,
    relayers: table::Table<address, bool>,
    relayer_count: u64,
}

// ===== Events =====

/// Emitted when a relayer's status is updated.
public struct RelayerSet has copy, drop {
    relayer: address,
    is_active: bool,
}

// ===== View functions =====

/// Gets the number of whitelisted relayers.
///
/// Args:
///
/// relayer_registry: The shared relayer registry object.
///
/// Returns the number of active relayers.
public fun get_relayer_count(relayer_registry: &RelayerRegistry): u64 {
    relayer_registry.relayer_count
}

/// Checks if the given address is a whitelisted relayer or not.
///
/// Args:
///
/// relayer_registry:   The shared relayer registry object.
/// user:               The user address.
///
/// Returns a bool indicating whether the given address is a whitelisted relayer or not.
public fun is_whitelisted_relayer(relayer_registry: &RelayerRegistry, user: address): bool {
    relayer_registry.relayers.contains(user)
            && *relayer_registry.relayers.borrow(user)
}

// ===== Admin functions =====

/// Allows the owner (with owner capability object) to update a relayer's status (whitelist/remove).
///
/// Args:
///
/// _owner_cap:         The owner capability object.
/// relayer_registry:   The shared relayer registry object.
/// relayer:            The relayer address.
/// is_active:          To whitelist or remove the given relayer.
public entry fun set_relayer(
    _owner_cap: &owner::OwnerCap,
    relayer_registry: &mut RelayerRegistry,
    relayer: address,
    is_active: bool,
) {
    if (relayer_registry.relayers.contains(relayer)) {
        let relayer_status = relayer_registry.relayers.borrow_mut(relayer);
        assert!(*relayer_status != is_active, errors::relayer_status_update_not_required());

        *relayer_status = is_active;
        if (is_active) {
            relayer_registry.relayer_count = relayer_registry.relayer_count + 1;
        } else {
            relayer_registry.relayer_count = relayer_registry.relayer_count - 1;
        }
    } else {
        assert!(is_active, errors::relayer_status_update_not_required());

        relayer_registry.relayers.add(relayer, is_active);
        relayer_registry.relayer_count = relayer_registry.relayer_count + 1;
    };

    event::emit(RelayerSet {
        relayer,
        is_active,
    });
}

// ===== Private functions =====

/// Creates the shared relayer registry object during module initialization.
///
/// Args:
///
/// _otw:   The one time witness generated by Move during initialization.
/// ctx:    The transaction context.
fun init(_otw: MANAGE_RELAYERS, ctx: &mut TxContext) {
    let relayer_registry = RelayerRegistry {
        id: object::new(ctx),
        relayers: table::new(ctx),
        relayer_count: 0,
    };

    transfer::share_object(relayer_registry);
}

// ===== Test only =====

#[test_only]
public fun init_for_testing(ctx: &mut TxContext) {
    let otw = MANAGE_RELAYERS {};

    init(otw, ctx);
}
