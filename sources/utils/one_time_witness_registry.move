module mobility_protocol::one_time_witness_registry;

use mobility_protocol::errors;
use sui::bag;
use sui::table;

// ===== One time witness structs =====

/// Serves as the one time witness to create the domain-wise one time witness
/// registry during module initialization.
public struct ONE_TIME_WITNESS_REGISTRY has drop {}

// ===== Global storage structs =====

/// Domain-wise one time witness registry to ensure that certain objects can
/// only be created once, or certain actions can only be performed once. Holds
/// the registry table with the structure domain (u16) -> key (dynamic type) ->
/// witness_used (bool).
public struct OneTimeWitnessRegistry has key {
    id: object::UID,
    registry: table::Table<u16, bag::Bag>,
}

// ===== View functions =====

/// Checks if the one time witness for the given domain and key has already been
/// used or not.
///
/// Args:
///
/// one_time_witness_registry:  Immutable reference to the one time witness
///                             registry shared object.
/// domain:                     The domain for certain actions.
/// key:                        The dynamic key used to check if the one time
///                             witness has been used or not for the given domain.
///
/// Returns a bool indicating whether the one time witness has been used or not.
public fun is_domain_one_time_witness_used<T: copy + drop + store>(
    one_time_witness_registry: &OneTimeWitnessRegistry,
    domain: u16,
    key: T,
): bool {
    let (is_domain_one_time_witness_used, _) = is_domain_one_time_witness_used_and_domain_exists(
        one_time_witness_registry,
        domain,
        key,
    );

    is_domain_one_time_witness_used
}

// ===== Package functions =====

/// Allows friend modules to use the domain-wise one time witness. It should be the
/// responsibility of the friend modules to work in their own domains, and not use
/// domains of other friends. Reverts if already used.
///
/// Args:
///
/// one_time_witness_registry:  Immutable reference to the one time witness
///                             registry shared object.
/// domain:                     The domain for certain actions.
/// key:                        The dynamic key used to check if the one time
///                             witness has been used or not for the given domain.
/// ctx:                        The transaction context.
public(package) fun use_witness<T: copy + drop + store>(
    one_time_witness_registry: &mut OneTimeWitnessRegistry,
    domain: u16,
    key: T,
    ctx: &mut TxContext,
) {
    let (
        is_domain_one_time_witness_used,
        domain_exists,
    ) = is_domain_one_time_witness_used_and_domain_exists(
        one_time_witness_registry,
        domain,
        key,
    );
    assert!(!is_domain_one_time_witness_used, errors::already_used_domain_one_time_witness());

    if (!domain_exists) create_domain(one_time_witness_registry, domain, ctx);
    one_time_witness_registry.registry.borrow_mut(domain).add(key, true);
}

// ===== Private functions =====

/// Creates the domain-wise one time witness registry during module initialization.
/// Registry is shared and viewable by anyone.
///
/// Args:
///
/// _otw:   The one time witness generated by Move during initialization.
/// ctx:    The transaction context.
fun init(_otw: ONE_TIME_WITNESS_REGISTRY, ctx: &mut TxContext) {
    let witness_registry = OneTimeWitnessRegistry {
        id: object::new(ctx),
        registry: table::new(ctx),
    };

    transfer::share_object(witness_registry);
}

/// Checks if the one time witness for the given domain and key has already been
/// used or not.
///
/// Args:
///
/// one_time_witness_registry:  Immutable reference to the one time witness
///                             registry shared object.
/// domain:                     The domain for certain actions.
/// key:                        The dynamic key used to check if the one time
///                             witness has been used or not for the given domain.
///
/// Returns a bool indicating whether the one time witness has been used or not, and
/// another bool indicating whether the domain exists or not.
fun is_domain_one_time_witness_used_and_domain_exists<T: copy + drop + store>(
    one_time_witness_registry: &OneTimeWitnessRegistry,
    domain: u16,
    key: T,
): (bool, bool) {
    if (!one_time_witness_registry.registry.contains(domain)) {
        (false, false)
    } else {
        let one_time_witness_registry_for_domain = one_time_witness_registry
            .registry
            .borrow(domain);

        (one_time_witness_registry_for_domain.contains(key), true)
    }
}

/// Internal function called by the `use_witness` function to create a domain while
/// using the one time witness if the domain doesn't exist in the registry yet.
///
/// Args:
///
/// one_time_witness_registry:  Immutable reference to the one time witness
///                             registry shared object.
/// domain:                     The domain for certain actions.
/// ctx:                        The transaction context.
fun create_domain(
    one_time_witness_registry: &mut OneTimeWitnessRegistry,
    domain: u16,
    ctx: &mut TxContext,
) {
    one_time_witness_registry.registry.add(domain, bag::new(ctx));
}

// ===== Test only =====

#[test_only]
public fun init_for_testing(ctx: &mut TxContext) {
    let otw = ONE_TIME_WITNESS_REGISTRY {};

    init(otw, ctx);
}
